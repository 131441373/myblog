## 正则规则

#### 匹配本身
`abc`

#### 转义字符
`\n`, `\t`
regex中这样用
`R"(str)"` 否则转义要打多一个括号
**注意这个括号是给R识别的，不属于regex的pattern，即与分组无关**
不过反过来，这个括号，可以视为就是regex的pattern也无妨，反而更直观，就当它是regex自动在两边补的括号

#### 字符族
`[adegxz]` 匹配a或d或d或e或g或x或z
`[a-z]` `[0-9]`全部小写字母/全部数字 (**还能[a-z0-9]** 这样连用)

`[^a-z]` 范围取反 **（ [^a] 这个也是取反）**,  **([a^] 这个不是取反)**, **(^[0-9]也不是取反，这个^是开头)**

**如果字符族里要用-这个字符，放在[]的最后面，否则有歧义**

常用字符族：
`\d`  等价于`[0-9]`
`\s` 匹配单个空白字符（这个不用空格代替，主要是可以`\s+`这样用
`\w` 匹配字母、数字、下划线 (**注意\w包含数字**
`\b` 匹配：前一个字符\w，后一个字符为\W。   或者   前一个字符为\W(或没有前一个字符), 所在位字符为\w
(**caution:  \b只占位，不匹配，即只起到检查作用， 如果要匹配，可以搭配 `\b\W`**)
(`\b`一般用于匹配单词，单词开头加个\b, 单词结尾加个\b， 避免那个单词是其他另外某个单词的前缀 or 后缀)
上述把反斜杠后面的字母转成大写时，表示上述字符族的范围取反

**字符族中 `.`, `|` 等字符就是那个字符，没有其他意思**
比如要匹配单独一个字符`.` 可以用 `\.` 也可用 `[.]` 

#### 特殊匹配字符
`^`开头 `$`结尾
`.` 任意单个字符

#### 重复模式
`x{n,m}` x中内容重复n~m次不等
`x{0, m}`x中内容重复m次以内
`x{n, 0}` x中内容重复n次以上
`x{n}` x中内容重复恰好n次

常用重复模式
`x?` = `x{0,1}`
`x+` = `x{1,}`
`x*` = `x{0,}`

默认重复模式为贪婪匹配，能匹配多少匹配多少
在重复模式后加一个问好，能够尽量少的匹配`x{1,2}?`

#### 或连接符
`mood|food`

**注意** `(.|-)` 的点是匹配任意字符的点， 要达到相似的功能则 `[.-]` ，字符族同样有或的意思，只不过每一部分只能是单一字符

#### 优先级 与 分组
打括号就好了
如`(m|f)ood`匹配 mood或food

括号的内容会进行分组
匹配时，会自动给最外层加一个大括号，分组按照从外往内，从左往右的顺序

使用`(?:regexpattern)`可以不匹配词分组

#### 后向引用
即在regex中使用前面已经获取的分组
如使用 `\1` 获取之前的第一号分组

例如`acha's name is acha.`
可以用`(\w+)'s name is \1.` 去匹配

#### 例子
`version(\d+.\d+)` 获取 `version12.54`等版本号
`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`匹配ip地址（前面是数位dp似的匹配法，加上点后重复三次，最后没有点，特殊处理
-?\d+([.]\d*)? 匹配可正可负，小数可有可无，甚至可匹配`1.`这种小数点数字可有可无

## regex使用
#### 定义
用regex("..") 来定义正则规则
用smatch res来接收各分组的内容

也可用string去构造regex

例如
((a)bc(.))(def)  去 匹配`abc1def`
res[0]`abc1def`, res[1]`abc1`,res[2]`a`, res[3]`1`, res[4]`def`

#### regex_match
完全匹配，两边没多余字符
regex_match(str, res, regex) 或 regex_match(str, regex)型
返回值为bool

#### regex_search
匹配第一个满足的子串
调用方式同

#### regex_replace

#### regex辅助工具
```
std::smatch search(const std::string& str) {
    std::regex regex(str);
    std::smatch res;
    std::regex_search(s, res, regex);
    return res;
}
```
然后用 返回值的empty代替 regex_search的返回值bool。 
这样的话， 就不用每次一行一个regex，一行一个ssmath，一行一个search了
如果确保不是empty的话，甚至可以`search(R"(\d{11})")[0]` 这么写