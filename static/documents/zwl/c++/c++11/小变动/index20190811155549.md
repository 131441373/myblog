### 容器嵌套时两个>>中间不再需要强制空格

`vector<vector<int>> v;`

### nullptr

`f(int)`和`f(void*)`中，旧版的`NULL`（定义成了0）在传参时会被认为是`int`，新版的`nullptr`不存在误解

### explicit从1到多

不加explicit时，对`complex(double r, double i=0);`的构造函数
是可以在`CP x = 5; x = x + 4;`的时候，隐式地对整形进行complex构造的

但如果不希望编译器自做聪明的话
就在构造函数前加上explicit声明， 表示必须要显示调用构造函数才可构造

从一到多后，`x={1,2}`不合法, 要`x{1,2}`才可

### for(decl : coll)

类似py的`for  in `, 本质是iterator迭代，然后每次将*iterator换为decl
```c++
set<int>v;
for (auto x : v) cout << x << endl;
for (const auto& x : v) cout << x << endl; //这是不可改的类型，所以加引用时配上const
```

### =default, =delete
c++默认给出 无参构造函数， 析构函数， 拷贝构造函数， 拷贝赋值运算符
比如构造函数，你实现了有参的构造函数，那程序就不会帮你合成默认构造函数了

`=delete`貌似还可用于 类继承时子类删除掉父类的某个函数（不需要改写但不想要时）。 不知道设计时有没有这种考虑

### using =
对于带模板的别名：
`template<typename T> using Vec = std::vector<T>` 注意`Vec`后不用加`<T>`
然后`Vec<int>`即可

另外优化了函数指针的别名写法，使得哪个是类型更清晰
`typedef void(*fptr)(int);`的表示为`using func = void(*)(int)`

### override
虚函数子类重写时，在函数后大括号前加入 override关键字，表示我想重载
万一不小心把变量类型打错了跟父类不一样，编译器就会提醒你。如果不写关键字，就变成了一个新函数

### final
用于类声明后，表示该类不能再被继承
用于虚函数声明后，表示该虚函数不能在子类被重写

### 容器insert返回值
insert是在某个位置前插入元素
现在插入元素后返回值为新元素的位置，也即可以对返回值接着insert插在原来的位置
只不过每次都是往前

### 类内初始化
可以对类内成员进行如`int x = 0;`， `int a[3]{0}`等
然后构造函数会在这种类内初始化的基础上再去进行

### 委托构造函数
```c++
class A {
	int x, y;
public:
	A(int x):x(x) {y = 0;}
	A():A(1) {y = 1;}
	A(const A& a):A(a.x) {y = 2;}
	void print() {std::cout << x << " " << y << std::endl;}
};

int main() {
	A a; a.print();		// 1 1
	A b(0); b.print();	// 0 0
	A c(a); c.print();	// 1 2
```

### string于数值类型转换
`std::to_string(value)`转换数值为字符串

`stoi, stol stoul stoll stoull stof stod stold`
分别表示string类型转为int,long,unsigned long, long long, unsigned long long, float, double, long double

### vector的emplace
```c++
std::vector<std::pair<int, int>> v;

int main() {
	v.push_back(std::pair<int,int>{1, 1});
	v.emplace_back(1, 1); //与上面等价
```