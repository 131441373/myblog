### 空间分配
#### operator new/delete
是类内自己定义 的，如`A::operator new`
c++还有个默认的`::operator new`

#### new/delete operator
new = operator new + constructor
delete = destructor + operator delete

#### placement new
在一个指定的地址创建对象并返回指针

#### example
```c++
void* place = ::operator new(sizeof(int));
int *p = new(place) int(1);
//int *p = new int(1);
```

## <memory>
### <bits/allocator.h>
```c++
template<typename _Tp>
  class allocator: public __allocator_base<_Tp>
  {
  public:
    typedef size_t     size_type; // 各种类型typedef
    typedef ptrdiff_t  difference_type;
    typedef _Tp*       pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp&       reference;
    typedef const _Tp& const_reference;
    typedef _Tp        value_type;

    template<typename _Tp1>
	struct rebind { typedef allocator<_Tp1> other; }; // 下面分析
```
父类`__allocator_base`定义在`/usr/include/x86_64-linux-gnu/c++/7.4.0/bits`里
`# define __allocator_base  __gnu_cxx::new_allocator`

而`new_allocator`定义在`ext/new_allocator.h`
里面有allocator和deallocate函数，是对operator new/delete的一个小封装

rebind帮template更换尖括号里的参数
（因为c++没有拆尖括号的语法，而比如`list<int>`它需要alloc int,也需要_List_node<int>
我们希望这两东西的空间分配方式相同，但是list<int>默认template传参只传了关于int的allocator
这是rebind就可以派上用场了

### <stl_construct.h>
construct
destroy

### <stl_uninitialized.h>

## <ext/alloc_traits.h>
用的namespace __gnu_cxx
继承下面
### <bits/alloc_traits.h>
用的namespace std
定义allocator_traits(和__allocator_traits_base)
