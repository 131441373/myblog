namespace std _GLIBCXX_VISIBILITY(default)
{
	template<typename _Tp, typename _Alloc>
		struct _Vector_base
		{
			typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other	 _Tp_alloc_type; // allocator<_Tp>
			typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer	 pointer; // _Tp*

			struct _Vector_impl : public _Tp_alloc_type
			{
				pointer _M_start;
				pointer _M_finish;
				pointer _M_end_of_storage;

				_Vector_impl() : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage() { }
				// default construction
				_Vector_impl(_Tp_alloc_type const& __a) : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage() { }
				_Vector_impl(_Tp_alloc_type&& __a) noexcept : _Tp_alloc_type(std::move(__a)), _M_start(), _M_finish(), _M_end_of_storage() { }
				//construction with allocator

				void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT // 只是swap指针
				{
					std::swap(_M_start, __x._M_start);
					std::swap(_M_finish, __x._M_finish);
					std::swap(_M_end_of_storage, __x._M_end_of_storage);
				}
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type& _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type& _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base() : _M_impl() { }
      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT : _M_impl(__a) { } // Vector_base的构造就是_M_impl的构造

      _Vector_base(size_t __n) : _M_impl() { _M_create_storage(__n); } // _M_create_storage在最下面的private里实现
      _Vector_base(size_t __n, const allocator_type& __a) : _M_impl(__a) { _M_create_storage(__n); }

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start); } // 从start开始dealloc容量个

    public:
      _Vector_impl _M_impl;

      pointer _M_allocate(size_t __n) {
				typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
				return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer(); // allocator<_Tp>::allocate 或 nullptr
      }

      void _M_deallocate(pointer __p, size_t __n) {
				typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
				if (__p) _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void _M_create_storage(size_t __n) {
				this->_M_impl._M_start = this->_M_allocate(__n); //分配并获取头指针
				this->_M_impl._M_finish = this->_M_impl._M_start; //初始啥都没存
				this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n; //容量
      }
    };
