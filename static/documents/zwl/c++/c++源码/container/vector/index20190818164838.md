```c++
namespace std _GLIBCXX_VISIBILITY(default)
{
	template<typename _Tp, typename _Alloc>
		struct _Vector_base // 只存指针，不存对象，vector_base里不处理 Ctor, Dtor
		{
			typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other	 _Tp_alloc_type; // allocator<_Tp>
			typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer	 pointer; // _Tp* //todo

			struct _Vector_impl : public _Tp_alloc_type // 只需要知道内存，不用存对象
			{
				pointer _M_start;
				pointer _M_finish;
				pointer _M_end_of_storage;

				// constructor
				_Vector_impl()
				: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage() { }
				_Vector_impl(_Tp_alloc_type const& __a)
				: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage() { }

				void _M_swap_data(_Vector_impl& __x)  // 只是swap指针
				{
					std::swap(_M_start, __x._M_start);
					std::swap(_M_finish, __x._M_finish);
					std::swap(_M_end_of_storage, __x._M_end_of_storage);
				}
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type& _M_get_Tp_allocator() 
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type& _M_get_Tp_allocator() const 
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type get_allocator() const  { return allocator_type(_M_get_Tp_allocator()); } // 常用于比较两个迭代器是否相同

			// constructor
      _Vector_base() // 声明时如果不指定大小，则先不分配任何内存，让impl里的start,finish都为null
			: _M_impl() { } 
      _Vector_base(const allocator_type& __a) // Vector_base的构造就是_M_impl的构造
			: _M_impl(__a) { }
      _Vector_base(size_t __n) // _M_create_storage在最下面的private里实现
			: _M_impl() { _M_create_storage(__n); }
      _Vector_base(size_t __n, const allocator_type& __a)
			: _M_impl(__a) { _M_create_storage(__n); }

			// destructor
      ~_Vector_base() 
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start); } // 从start开始dealloc容量个

    public:
      _Vector_impl _M_impl;

      pointer _M_allocate(size_t __n) {
				typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
				return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer(); // allocator<_Tp>::allocate 或 nullptr
      }

      void _M_deallocate(pointer __p, size_t __n) {
				typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
				if (__p) _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void _M_create_storage(size_t __n) {
				this->_M_impl._M_start = this->_M_allocate(__n); //分配并获取头指针
				this->_M_impl._M_finish = this->_M_impl._M_start; //初始啥都没存
				this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n; //容量
      }
    };

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      typedef _Vector_base<_Tp, _Alloc>			_Base;
      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
			//又到了c++11喜闻乐见的疯狂萃取环节

    public:
      typedef _Tp					value_type;
      typedef typename _Base::pointer			pointer; // 本质跟下三行一样，只不过已经trait过了
      typedef typename _Alloc_traits::const_pointer	const_pointer;
      typedef typename _Alloc_traits::reference		reference;
      typedef typename _Alloc_traits::const_reference	const_reference;

      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector> const_iterator;

      typedef std::reverse_iterator<iterator>		reverse_iterator;
      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;

      typedef size_t					size_type;
      typedef ptrdiff_t					difference_type;
      typedef _Alloc					allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;
			//继续萃取

    public:
			// constructor
      vector()
			: _Base() { }
      explicit vector(const allocator_type& __a)
			: _Base(__a) { }
      explicit vector(size_type __n, const value_type& __value = value_type(), const allocator_type& __a = allocator_type())
      : _Base(__n, __a) { _M_fill_initialize(__n, __value); }

			// copy constructor
      vector(const vector& __x)
			: _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator())) {
				this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
      }

			// todo
      template<typename _InputIterator>
			vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a = allocator_type())
			: _Base(__a) {
				// Check whether it's an integral type.  If so, it's not an iterator.
				typedef typename std::__is_integer<_InputIterator>::__type _Integral;
				_M_initialize_dispatch(__first, __last, _Integral());
			}

      ~vector()  { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator()); }

      vector& operator=(const vector& __x); //实现在tcc，拷贝后capacity为x的size，即未使用的空间不会被拷贝

      void assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }
			// 如果n<capacity, 修改后size=n，capacity不变;  如果n>capacity, 修改后size=capacity=n

		// todo
      template<typename _InputIterator>
			void assign(_InputIterator __first, _InputIterator __last) {
				// Check whether it's an integral type.  If so, it's not an iterator.
				typedef typename std::__is_integer<_InputIterator>::__type _Integral;
				_M_assign_dispatch(__first, __last, _Integral());
			}

      using _Base::get_allocator;

      iterator begin()  { return iterator(this->_M_impl._M_start); }
      iterator end()  { return iterator(this->_M_impl._M_finish); }
      const_iterator cbegin() const noexcept { return const_iterator(this->_M_impl._M_start); }
			const_iterator cend() const noexcept { return const_iterator(this->_M_impl._M_finish); }

      reverse_iterator rbegin()  { return reverse_iterator(end()); }
      reverse_iterator rend()  { return reverse_iterator(begin()); } 
      const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(end()); }
      const_reverse_iterator crend() const noexcept { return const_reverse_iterator(begin()); }

      size_type size() const  { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
      size_type capacity() const  { return size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_start); }
      size_type max_size() const  { return _Alloc_traits::max_size(_M_get_Tp_allocator()); } // very very huge

      void resize(size_type __new_size, value_type __x = value_type()) {
				if (__new_size > size())//扩大并用x填充
					_M_fill_insert(end(), __new_size - size(), __x);
				else if (__new_size < size()) //缩小则与x无关了
					_M_erase_at_end(this->_M_impl._M_start + __new_size);
      }

      bool empty() const  { return begin() == end(); }

      void reserve(size_type __n); //实现在tcc，如果n>capacity才有用，用于预留足够的capacity，减少不必要的动态加长

      reference operator[](size_type __n)  { return *(this->_M_impl._M_start + __n); } //要理解这句

      const_reference operator[](size_type __n) const  { return *(this->_M_impl._M_start + __n); }

    protected:
      void _M_range_check(size_type __n) const { // at(idx)语句需要用到的检测，[idx]不检测
				if (__n >= this->size())
					__throw_out_of_range_fmt(__N("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
      }

    public:
      reference at(size_type __n) { _M_range_check(__n); return (*this)[__n]; } // 实际上是检测完，然后调用[idx]
      const_reference at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }

      reference front()  { return *begin(); } // 这几行在实际源码里有个glibcxx开头的东西检测容器是否empty
      const_reference front() const { return *begin(); }
      reference back() { return *(end() - 1); }
      const_reference back() const { return *(end() - 1); }

			// todo
      _Tp* 
      data() 
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const 
      { return _M_data_ptr(this->_M_impl._M_start); }
			// todo

      void push_back(const value_type& __x) {
				if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
					_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
					++this->_M_impl._M_finish;
				}
				else _M_realloc_insert(end(), __x); //实现在tcc //todo
      }

      void pop_back() { --this->_M_impl._M_finish; _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish); }
			// 源码有个glibcxx的东西先检测原来是否为空。  注意左闭右开，所以先--finish再destroy

      iterator insert(iterator __position, const value_type& __x); //实现在tcc //todo
      void insert(iterator __position, size_type __n, const value_type& __x) { _M_fill_insert(__position, __n, __x); }
      template<typename _InputIterator>
			void insert(iterator __position, _InputIterator __first, _InputIterator __last) { // todo
				// Check whether it's an integral type.  If so, it's not an iterator.
				typedef typename std::__is_integer<_InputIterator>::__type _Integral;
				_M_insert_dispatch(__position, __first, __last, _Integral());
			}

      iterator erase(iterator __position) { return _M_erase(__position); } // todo
      iterator erase(iterator __first, iterator __last) { return _M_erase(__first, __last); } // todo

      void swap(vector& __x)  {
				this->_M_impl._M_swap_data(__x._M_impl); //交换资源
				_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); //交换allocator
      }

      void clear() { _M_erase_at_end(this->_M_impl._M_start); } 

    protected: // todo
      /**
       *  Memory expansion handler.  Uses the member allocation function to
       *  obtain @a n bytes of memory, and then copies [first,last) into it.
       */
      template<typename _ForwardIterator>
	pointer
	_M_allocate_and_copy(size_type __n,
			     _ForwardIterator __first, _ForwardIterator __last)
	{
	  pointer __result = this->_M_allocate(__n);
	  __try
	    {
	      std::__uninitialized_copy_a(__first, __last, __result,
					  _M_get_Tp_allocator());
	      return __result;
	    }
	  __catch(...)
	    {
	      _M_deallocate(__result, __n);
	      __throw_exception_again;
	    }
	}

      template<typename _Integer>
			void _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type) {
				this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
				this->_M_impl._M_end_of_storage = this->_M_impl._M_start + static_cast<size_type>(__n);
				_M_fill_initialize(static_cast<size_type>(__n), __value);
			}

      template<typename _InputIterator>
			void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, __false_type) {
				typedef typename std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
				_M_range_initialize(__first, __last, _IterCategory());
			}
		// todo

      template<typename _InputIterator>
			void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
				__try {
					for (; __first != __last; ++__first)
						emplace_back(*__first);
				} __catch(...) {
					clear();
					__throw_exception_again;
				}
			} // uninitialize中的commit or rollback机制

      template<typename _ForwardIterator>
			void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) { // uninit_copy
				const size_type __n = std::distance(__first, __last);
				this->_M_impl._M_start = this->_M_allocate(__n);
				this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
				this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
			}

      void _M_fill_initialize(size_type __n, const value_type& __value) { // uninit_fill
				this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
      }

      void _M_default_initialize(size_type __n) { // uninit_default
				this->_M_impl._M_finish = std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, _M_get_Tp_allocator());
      }


	//todo
      // Internal assign functions follow.  The *_aux functions do the actual
      // assignment work for the range versions.

      // Called by the range assign to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
	void
	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
	{ _M_fill_assign(__n, __val); }

      // Called by the range assign to implement [23.1.1]/9
      template<typename _InputIterator>
	void
	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
			   __false_type)
	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

      // Called by the second assign_dispatch above
      template<typename _InputIterator>
	void
	_M_assign_aux(_InputIterator __first, _InputIterator __last,
		      std::input_iterator_tag);

      // Called by the second assign_dispatch above
      template<typename _ForwardIterator>
	void
	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
		      std::forward_iterator_tag);

      // Called by assign(n,t), and the range assign when it turns out
      // to be the same thing.
      void
      _M_fill_assign(size_type __n, const value_type& __val);

      // Internal insert functions follow.

      // Called by the range insert to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
	void
	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
			   __true_type)
	{ _M_fill_insert(__pos, __n, __val); }

      // Called by the range insert to implement [23.1.1]/9
      template<typename _InputIterator>
	void
	_M_insert_dispatch(iterator __pos, _InputIterator __first,
			   _InputIterator __last, __false_type)
	{
	  _M_range_insert(__pos, __first, __last,
			  std::__iterator_category(__first));
	}

      // Called by the second insert_dispatch above
      template<typename _InputIterator>
	void
	_M_range_insert(iterator __pos, _InputIterator __first,
			_InputIterator __last, std::input_iterator_tag);

      // Called by the second insert_dispatch above
      template<typename _ForwardIterator>
	void
	_M_range_insert(iterator __pos, _ForwardIterator __first,
			_ForwardIterator __last, std::forward_iterator_tag);

      // Called by insert(p,n,x), and the range insert when it turns out to be
      // the same thing.
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);

#if __cplusplus < 201103L
      // Called by insert(p,x)
      void
      _M_insert_aux(iterator __position, const value_type& __x);

      void
      _M_realloc_insert(iterator __position, const value_type& __x);
#else
      // A value_type object constructed with _Alloc_traits::construct()
      // and destroyed with _Alloc_traits::destroy().
      struct _Temporary_value
      {
	template<typename... _Args>
	  explicit
	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
	  {
	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
				     std::forward<_Args>(__args)...);
	  }

	~_Temporary_value()
	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

	value_type&
	_M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
	pointer
	_M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

	vector* _M_this;
	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };

      // Called by insert(p,x) and other functions when insertion needs to
      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
      template<typename _Arg>
	void
	_M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
	void
	_M_realloc_insert(iterator __position, _Args&&... __args);

      // Either move-construct at the end, or forward to _M_insert_aux.
      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);

      // Try to emplace at the end, otherwise forward to _M_insert_aux.
      template<typename... _Args>
	iterator
	_M_emplace_aux(const_iterator __position, _Args&&... __args);

      // Emplacing an rvalue of the correct type can use _M_insert_rval.
      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }
#endif

      // Called by _M_fill_insert, _M_insert_aux etc.
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
	return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void _M_erase_at_end(pointer __pos) { // 从后往前一直删，到把pos也删了后结束
				std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
				this->_M_impl._M_finish = __pos; // 左闭右开
      }

      iterator _M_erase(iterator __position); // 实现在tcc // todo
      iterator _M_erase(iterator __first, iterator __last); // 实现在tcc // todo

#if __cplusplus >= 201103L
    private:
      // Constant-time move assignment when source object's memory can be
      // moved, either because the source's allocator will move too
      // or because the allocators are equal.
      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
	vector __tmp(get_allocator());
	this->_M_impl._M_swap_data(__tmp._M_impl);
	this->_M_impl._M_swap_data(__x._M_impl);
	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }

      // Do move assignment when it might not be possible to move source
      // object's memory, resulting in a linear-time operation.
      void
      _M_move_assign(vector&& __x, std::false_type)
      {
	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
	  _M_move_assign(std::move(__x), std::true_type());
	else
	  {
	    // The rvalue's allocator cannot be moved and is not equal,
	    // so we need to individually move each element.
	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
			 std::__make_move_if_noexcept_iterator(__x.end()));
	    __x.clear();
	  }
      }
#endif

      template<typename _Up>
	_Up*
	_M_data_ptr(_Up* __ptr) const 
	{ return __ptr; }

#if __cplusplus >= 201103L
      template<typename _Ptr>
	typename std::pointer_traits<_Ptr>::element_type*
	_M_data_ptr(_Ptr __ptr) const
	{ return empty() ? nullptr : std::__addressof(*__ptr); }
#else
      template<typename _Up>
	_Up*
	_M_data_ptr(_Up* __ptr) 
	{ return __ptr; }

      template<typename _Ptr>
	value_type*
	_M_data_ptr(_Ptr __ptr)
	{ return __ptr.operator->(); }

      template<typename _Ptr>
	const value_type*
	_M_data_ptr(_Ptr __ptr) const
	{ return __ptr.operator->(); }
#endif
    };

	// operator == != < > <= >=
  template<typename _Tp, typename _Alloc>
    inline bool operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin())); } // std::equal

  template<typename _Tp, typename _Alloc>
    inline bool operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); } //只实现==

  template<typename _Tp, typename _Alloc>
    inline bool operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end()); } // std::lexicographical_compare

  template<typename _Tp, typename _Alloc>
    inline bool operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; } //只实现<

  template<typename _Tp, typename _Alloc>
    inline bool operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); } //只实现<

  template<typename _Tp, typename _Alloc>
    inline bool operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); } //只实现<

  template<typename _Tp, typename _Alloc>
    inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y) { __x.swap(__y); }
}
```