## <bits/stl_list.h>
### _List_node
```c++
namespace __detail {
struct _List_node_base
{
  _List_node_base* _M_next;
  _List_node_base* _M_prev;
  ...
}
}
```

```c++
template<typename _Tp>
  struct _List_node : public __detail::_List_node_base
  {
    _Tp _M_data;
    _Tp*       _M_valptr()       { return std::__addressof(_M_data); }
    _Tp const* _M_valptr() const { return std::__addressof(_M_data); } //_Tp const <=> const _Tp
  };
```
### _List_iterator
```c++
template<typename _Tp>
struct _List_iterator
{
  typedef _List_iterator<_Tp>		_Self;
  typedef _List_node<_Tp>			_Node;
// iterator五大trait
  typedef ptrdiff_t				difference_type;
  typedef std::bidirectional_iterator_tag	iterator_category; // 双向链表，无法随机访问
  typedef _Tp				value_type;
  typedef _Tp*				pointer;
  typedef _Tp&				reference;

  __detail::_List_node_base* _M_node;
  ...类的构造函数等

  // Must downcast from _List_node_base to _List_node to get to value.
  reference
  operator*() const _GLIBCXX_NOEXCEPT
  { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

  pointer
  operator->() const _GLIBCXX_NOEXCEPT
  { return static_cast<_Node*>(_M_node)->_M_valptr(); }

  _Self&
  operator++() _GLIBCXX_NOEXCEPT
  {
_M_node = _M_node->_M_next;
return *this;
  }

  _Self
  operator++(int) _GLIBCXX_NOEXCEPT
  {
_Self __tmp = *this;
_M_node = _M_node->_M_next;
return __tmp;
  }

  _Self&
  operator--() _GLIBCXX_NOEXCEPT
  {
_M_node = _M_node->_M_prev;
return *this;
  }

  _Self
  operator--(int) _GLIBCXX_NOEXCEPT
  {
_Self __tmp = *this;
_M_node = _M_node->_M_prev;
return __tmp;
  }

  bool
  operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
  { return _M_node == __x._M_node; }

  bool
  operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
  { return _M_node != __x._M_node; }
};
```