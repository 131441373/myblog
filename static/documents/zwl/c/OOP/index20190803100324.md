## 权限
public
private
protected 类似private，但继承可以访问

## 构造和析构
注意函数可以重载，所以可以同时写有参构造和无参构造
类嵌套时，先构造子，再构造父； 先析构父，再析构子
```c++
class A{
private:
    int name;
public:
    A() {name = 1;} //无参构造
    A(int _name) {name = _name;} //有参构造，这里不一定要设传参默认值，但前提要写无参构造
    A(int name):name(name) {...} //有参构造另一写法
    A(class A& y) {name = y.name;} //拷贝构造，这个设定影响函数传参中 实参->形参 那一步
}
```
注意对于拷贝构造函数，不写时默认时全部copy
但自己实现时，不可以写`*this = y`（经测试）
不然会和自定义的`=`运算符起冲突（导致两个都运行然后segment fault之类的

正确实现时：
`A x(y)`或者`A x = y`都 调用拷贝构造，且不调用`=`运算符
`A x; x = y` 调用`=`运算符

## 成员
静态成员不占用对象的存储空间（占用类的
静态成员函数只能访问静态成员变量
静态成员变量初始化可以如下：
```c++
class A{
    static int x;
};
int A::x = 1; //要加上类型，不能写main里
int main() {
}
```

非静态成员函数也不占用对象的存储空间（占用类的
非静态成员变量占用对象的存储空间

`A::`前缀可以类外声明成员函数(内部需要先声明

## const修饰
`f() const {}`常函数：不允许修改成员变量
`mutable int x;`修饰后的成员变量可被常函数修改

## 友元
作为好朋友，可以访问私有属性
friend修饰，表示指定xxx可以访问自己
可用于类B中含有A类型指针 或 A类型变量，可用于重载运算符等

法1：全局函数作友元：在类中声明函数，前缀`friend`
（如果要在外部实现，外部那次不用再写friend）

法2：成员函数作友元：类A中声明`friend void B::f();`表示允许类B的f函数访问A的私有属性

法3：友元类：在类A中声明`friend class B;`表示B可以访问A（不代表B可以访问A）
友元类有单向性，无传递性，不继承（符合实际），声明后B的对象不能直接访问到A属性，需要通过B的成员函数间接访问

## 重载
### 重载输出:
```c++
friend ostream& operator <<(ostream &cout, const A &x) {
    cout << x.blabla; // 不写endl
    return cout; //用于接后续的<<
}
```
### 重载++
```c++

```
