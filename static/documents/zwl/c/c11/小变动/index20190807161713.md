### 容器嵌套时两个>>中间不再需要强制空格

`vector<vector<int>> v;`

### nullptr

`f(int)`和`f(void*)`中，旧版的`NULL`（定义成了0）在传参时会被认为是`int`，新版的`nullptr`不存在误解

### `explicit`从1到多

不加explicit时，对`complex(double r, double i=0);`的构造函数
是可以在`CP x = 5; x = x + 4;`的时候，隐式地对整形进行complex构造的

但如果不希望编译器自做聪明的话
就在构造函数前加上explicit声明， 表示必须要显示调用构造函数才可构造

从一到多后，`x={1,2}`不合法, 要`x{1,2}`才可

### for(decl : coll)

类似py的`for  in `, 本质是iterator迭代，然后每次将*iterator换为decl
```c++
set<int>v;
for (auto x : v) cout << x << endl;
for (const auto& x : v) cout << x << endl; //这是不可改的类型，所以加引用时配上const
```

### =default, =delete
c++默认给出 无参构造函数， 析构函数， 拷贝构造函数， 拷贝赋值运算符
比如构造函数，你实现了有参的构造函数，那程序就不会帮你合成默认构造函数了

`=delete`貌似还可用于 类继承时子类删除掉父类的某个函数（不需要改写但不想要时）。 不知道设计时有没有这种考虑

### using =
对于带模板的别名：
`template<typename T> using Vec = std::vector<T>` 注意`Vec`后不用加`<T>`
然后`Vec<int>`即可

另外优化了函数指针的别名写法，使得哪个是类型更清晰
`typedef void(*fptr)(int);`的表示为`using func = void(*)(int)`

### override
虚函数子类重写时，在函数后大括号前加入 override关键字，表示我想重载
万一不小心把变量类型打错了跟父类不一样，编译器就会提醒你。如果不写关键字，就变成了一个新函数

### final
用于类声明后，表示该类不能再被继承
用于虚函数声明后，表示该虚函数不能在子类被重写