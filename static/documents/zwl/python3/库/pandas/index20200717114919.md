excel一样的东西， 一列一个分类，一行一组数据
所以列叫columns, 行叫index

## Series
可理解为字典

用`.values`可以获取值 array
注意不是`values()`

用`.tolist()`可以获取值 list

## DataFrame
### 创建
`df=pd.DataFrame(np.array(xxx), index=, columns=)` 默认index和columns均为从0开始标号的序列

**在默认标号时，行和列的数字均既可作为标号，又可作为label ！！！！！！！！！！！！！！！**

**建议index用num， columns用label**

### 索引
#### label型
`df.loc[label]` 按行获取, `df.loc[:, label]`按列获取
`df.loc[[l1, l2]]` 获取两行, `df.loc[:, [l1, l2]]`获取两列,  `df.loc[[l1, l2], [l3,l4]]` 获取两行两列

#### label型2
只按列选的时候，`df.loc[:, label]` 等于 `df[label]` ， `df.loc[:, [l1, l2]]` 等于 `df[[l1, l2]]`

可用`df[(df['ab']>2) & (df['bc']<5)]` 进行筛选

还可以混用：`df[(df['ab']>2) & (df['bc']<5)]['ab']` 先筛选，然后取出自己有用的列

#### index型
iloc, 用法同label的五种形式

#### 循环遍历
行`for i, data in df.iterrows():`
列`for i, data in df.iteritems():`

这时 data 是 pandas里的Series(视为一维数组), 默认有从0开始的索引
此时既可以用原来column的label去访问, 也可以用第几列这样去访问

#### 条件筛选
`df['label']==xxx`
获得一个表, 满足条件的行为true, 不满足的为false

可以据此筛选出满足条件的行 `df[df['label']==xxx]`
也可以据此筛选出满足条件的行的编号 `df[df['label']==xxx].index`

### 修改
#### 增
索引后=xxx 表示将所有那个区域的数都改成xxx

`df[label] = np.nan` 可以扩充一列, `df[label] = pd.Series([xx,xx,xx], index=df.index)` 具体的扩充一列
`df.loc[n] = np.nan` 可以扩充一列, `df[label] = pd.Series([xx,xx,xx], index=df.columns)`具体的扩充一行

#### 删
删行:`df = df.drop(index=xxx)`
删列:`df = df.drop(columns=xxx)`
xxx可以是单个值,也可是list

条件删可以配合 `df[df['label'] == xxx].index`

**如果是Series**, 用`.drop(labels=xxx)`

### 表格形状

#### shape
shape[0] 行
shape[1] 列

#### concat
`pd.concat((a,b),axis=0, ignore_index=True)` 不ignore的话index会重复(不会重标号

默认join='outer', 表示label取并， 表中那个位置没有值的时候补np.nan
如果修改join='inner'， 表示label取交

或写成`a.append(b, ignore_index=True)`, `a.append([b,c], ignore_index=True)`

#### merge
pd.merge(lhs, rhs, on=['key1', 'key2']), how=默认inner

## 文件存储
读取`data = pd.read_xxx(path)`
存放`data.to_xxx(path)`

可以用 vim `:set fileencoding` 查看csv的编码
然后用 `pd.read_csv(path, encoding="xxx")`指定编码