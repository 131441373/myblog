excel一样的东西， 一列一个分类，一行一组数据
所以列叫columns, 行叫index

## 创建
`df=pd.DataFrame(np.array(xxx), index=, columns=)` 默认index和columns均为从0开始标号的序列

**在默认标号时，行和列的数字均既可作为标号，又可作为label ！！！！！！！！！！！！！！！**

**建议index用num， columns用label**

## 索引
#### label型
`df.loc[label]` 按行获取, `df.loc[:, label]`按列获取
`df.loc[[l1, l2]]` 获取两行, `df.loc[:, [l1, l2]]`获取两列,  `df.loc[[l1, l2], [l3,l4]]` 获取两行两列

#### label型2
只按列选的时候，`df.loc[:, label]` 等于 `df[label]` ， `df.loc[:, [l1, l2]]` 等于 `df[[l1, l2]]`

可用`df[(df['ab']>2) & (df['bc']<5)]` 进行筛选

还可以混用：`df[(df['ab']>2) & (df['bc']<5)]['ab']` 先筛选，然后取出自己有用的列

#### index型
iloc, 用法同label的五种形式

## 修改
索引后=xxx 表示将所有那个区域的数都改成xxx

`df[label] = np.nan` 可以扩充一列, `df[label] = pd.Series([xx,xx,xx], index=df.index)` 具体的扩充一列
`df.loc[n] = np.nan` 可以扩充一列, `df[label] = pd.Series([xx,xx,xx], index=df.columns)`具体的扩充一行

## 表格形状

#### concat
`pd.concat((a,b),axis=0, ignore_index=True)` 不ignore的话index会重复(不会重标号

默认join='outer', 表示label取并， 表中那个位置没有值的时候补np.nan
如果修改join='inner'， 表示label取交

或写成`a.append(b, ignore_index=True)`, `a.append([b,c], ignore_index=True)`

#### merge
pd.merge(lhs, rhs, on=['key1', 'key2']), how=默认inner

## plot
import matplotlib.pyplot as plt
data = pd.xxx
data.plot()
plt.show()

## 文件存储
读取`data = pd.read_xxx(path)`
存放`data.to_xxx(path)`