`pip3 install lxml`

`from lxml import etree`

### 从爬虫get的text中获得etree
`tree = etree.HTML(text)` 

如果要从文件中, 则`tree = etree.parse(filepath , etree.HTMLParser())`

### xpath表达式

#### 节点
`xx`某个标签
`@xx`某个属性
`text()`文本内容
`*` 通配
`@*` 属性通配

#### 路径

`/` 表示走进直接儿子, **采用的是广搜的模式(所有满足条件的路径都找出来)**
`/` 开头表示绝对路径(从根开始)

`//` 表示进入子树(即不需要是直接儿子, 子树就行)
`//` 开头表示从哪开始广搜都行

#### 谓词

`xx[position() <= 2]`　前2个
`xx[id]` 或 `xx[position() = id]`表示广搜那一层改成只取第id个, (id从1开始编号而非从0
`xx[last()]` 或 `xx[position() = last()]` 最后一个

`xx[yy]` xx满足有直接子标签 yy `xx[yy > 0]` yy的值还要满足个什么条件
`xx[@yy]`	xx满足其含有yy属性 `xx[@yy = zz]` yy的值还要满足个什么条件

复杂的:

`xx[position()=2 and @id='abc']` 含有bool表达式的 可以用 and or连接
`xx[]/yy[]`  (广搜的时候多层分别筛选)
`xx[yy[zz]]` `xx[yy[zz] > 0]`  (xx满足有子元素yy, yy还要有子元素zz (zz还要满足个什么条件)
`xx[@*='fuck']`  (含有属性值为fuck的元素

#### 其他
` | ` 或 (多个搜索方式) (或的是完整路径, 而不是某个子元素

### 常用方式
`node = tree.xpath(expression)[id]`  之后 node再想使用xpath时, 就用相对路径

