从记号生成 语法树

### 上下文无关文法 CFG (context free grammar 

```
S -> N V N
N -> s
  |  t
V -> a
  |  b
  |  c
```

其中S是分析源
大写字母为非终结符
小写字母为终结符
非终结符有多种解析方式，通过->记录
如果是concat，则同一行用空格连接
如果是or，则不同行用 `|` 连接

最左推导指：N V N中，先推导第一个N，再推V，而非从右往左

## 手工法
### 递归向下分析法（不能解决冲突
parse_N根据规则，switch根据情况调用N->A B中的parse_A, parse_B

### 避免冲突的可能方法（不能完全解决问题
#### 观察法
```
E -> E + T
   | E - T
   | T
T -> T * F
   | T / F
   | F
F -> num
   | ( E )
```
可以这样理解

$E=T\pm T\pm T\pm T\pm T\cdots $
$T=F \times/ F\times/ F\times/ F\times/ F\cdots $
$F=num~or~E$

```c++
def parse_E() {
  do {
    parse_T();
  } while(getNextToken() == '+' or '-');
}
def parse_T() {
  do {
    parse_F();
  } while(getNextToken() == '*' or '/');
}
def parse_F() {
  if (getNextToken() == '(') {
    parse_E();
    getNextToken(); // 读')'
  }
  else {
    unGetToken(); // unget一下
    getNum(); // 读数字
  }
}
```

## 自顶向下法

### LL(1)算法（无法处理冲突
从**左**向右读程序， 最**左**推导， 采用**一**个前看字符

工具 ANTLR 用了这个算法

算法：读入语法CFG，生成一个分析表（一个 非终结符-终结符的二维表格）：

1. 首先我们对每个非终结符求出其可能的开始符号集（第一个字符可能是什么
N->a b c的话 First(N) $\cup =$ a
N->A B C的话 First(N) $\cup =$ First(A)
由于可能存在环, 求First不一定能用递归法，所以才有迭代法，每次迭代按照上述规则更新所有集合，直到某次迭代没有任何集合发生变化为止
(对于终结符，First(a) = {a}即可)

2. 如果CFG包含eps
则需要预处理每个非终结符是否nullable，同样是迭代法
此时N->A B C 如果A B都是nullable
那么First(N)还要 $\cup=$ First(B), First(C)

3. 而如果N->A B C中，A B C都是nullable呢？
这是就要求Follow(N)
同样是迭代法，求出N在**所有**CFG规则中，后面可能跟点什么（这里用 ABC的倒序处理）

4. 利用First, Nullable, Follow，处理CFG的每条规则可能的首字符
构造出表：N-T, 每个非终结符N，在首字符T的限制下，可能使用哪些CFG规则
注意，这里说了哪“些”
由于1或2步骤中可能带来冲突，以及3步骤中考虑了实际匹配情况的超集，所以表中是可能出现各种冲突的
这个算法无法处理冲突，处理冲突的方式见后文

5. 匹配
最初把S压栈
迭代：
如果栈顶是终止符，看看和下一个token是否匹配
如果栈顶是非终止符，那么查表该终止符以及下一个token联合对应的表中，是哪条CFG规则，pop后将该规则**倒序**入栈
（因为每次处理栈顶，所以倒序入栈才能保证从左向右推导

### 避免冲突的可能方法（不能完全解决问题

#### 消除左递归
```
E -> E + T
 | T
```
称为左递归，即可以不断往左加东西，这样显然会产生冲突
于是修改为右递归
```
E -> T F
F -> + T F
  |
```

#### 消除左公因子
```
E -> a X
  -> a Y
```
称为左公因子，必然会产生冲突
修改为
```
E -> a F
F -> X
  |  Y
```

## 自底向上法
### LR(0)法 （仍有冲突

这样构造一个DFA

1. 设计一个超级源
`S' -> S $` 其中 `$`指EOF或行末

2. 定义闭包
如果当前节点包含规则 A -> B ...
那么需要把B的规则也加进来
如果新加进来的又有，则再加，依次类推

3. 定义转移
转移字符集为 全体 非终结符 或 终结符
该节点包含的所有规则中，->后以该转移符为开头的规则保留，同时->后删掉开头的该转义符，形成若干的新规则（额外需要记录该规则来自最初的哪条规则
这些规则张成闭包后形成一个新的节点
原来的节点向新节点连一条转义符的边

4. 匹配
定义规约态为该节点中含有一条 -> 右边为空的规则
定义终态为 S' -> S $ 走一个S一个$后到达的态
从匹配字符串一直读入字符在DFA上跑，跑过的节点压栈，跑过的字符压另一个栈
跑到规约态时，按照该规约态的原规则，两个栈均回溯 -> 右边字符数个数次，然后在DFA上跑一个 -> 左边字符，同理压栈
如果最后到达了终态说明匹配成功

### 避免冲突
#### 移进规约冲突
一个态里，既有->右边是空的，也有右边非空的，既可以前进，也可以规约

#### 优先级, 结合性 声明
以计算器为例
若一个节点，可规约的规则原来是 E->E+E, 不可规约的规则是 ->+E 和 ->*E
如果待匹配串的下一个字符是+，那么根据+号的左结合率，规约即可（同理如果右结合，那么不规约
如果待匹配串的下一个字符是*，那么根据*号的优先级，必须移进

同理若一个节点，可规约的规则原来是 E->E*E, 不可规约的规则是 ->+E 和 ->*E
那么读入+还是*，都是规约
