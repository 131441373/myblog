
### 前端优化(在AST上进行

#### 常量折叠
2+3+4*5这样的常量表达式，可以在编译期就计算出结果，弄成一个常数放在那里
即如果运算左子树和右子树都是NUM，那么把当前节点也设为NUM

#### 代数化简
a=0+b -> a=b
a=1*n -> a=b
2*a -> a+a 或 a<<1

### 中期优化（在控制流图

#### 死代码删除
case1：在控制流图中，可能存在死基本快：
从代码入口dfs遍历，没遍历到的块直接删除（入度为0，不可能走到那）（例如 continue之后还写东西，return之后还写

case2：在活性分析中，可能存在无用赋值
即一个赋值，赋值后没有用过（如a=x, x=2, a=x中的第一个a=x）（如 a=x, return 0; 的a=x)
在反向活性分析时，一般是在a=x时杀死a，但是如果a被杀死前，本就不在后继的生成集里，那么这就是无用赋值，可以删去

#### 常量传播
常量传播：用常数c定义了一个变量x，之后用了x，但是中间过程中x一直没有被进行操作 或 if语句中不可能走修改x的分支，这时可以把c进行传播，减少load次数
也或者，if有多个分支，但是多个分支里都把x附成了同一个常数，这时也可以优化

可以这样做：
把所有形如var=a的赋值语句编号index
最初定义每个赋值语句 index: x = a的生成集为{index}, 杀死集为变量x在除了这个语句外其他赋值语句中出现的index集合（原有赋值被覆盖（杀死））
定义每个非赋值语句的生成集和杀死集为空
按照程序框图跑，一个语句的生成集:=前驱(可能有多个分支跑过来，并起来即可)的生成集 去掉 该语句的杀死集，再并上该语句的生成集
由于可能有环，所以还是要用迭代法
最后，如果某个语句使用了变量var，而该语句的生成集中，赋值变量var的有且仅有一个index，那个index右边还是个常数，那么就可以传递了

传递过后，有可能导致可以进一步优化
所以上述算法的最后一步可以连跑好多次直到没有新的优化为止

#### 常量传播 与 常量折叠 轮替优化
传播后可能某些地方可以折叠
折叠后可能有可以传播
依此类推

### 后端优化

#### 寄存器分配
活性分析：活跃区间不相交的变量可以共用一个寄存器

可以这样做
定义赋值语句左侧为杀死集，右侧使用的变量为生成集
由于x活性为：x被赋值 到 x被下一次赋值前的最后一次使用
所以按照程序框图**反向**跑，即可得到活性区间
即 生成集:=后继的生成集去掉该语句的杀死集，再并上该语句的生成集